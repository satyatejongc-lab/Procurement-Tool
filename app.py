# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n4ouni3rXAFfRJEIpzB8BIzCXSem13bs
"""

import streamlit as st
import pandas as pd
import google.generativeai as genai
import time

# --- PAGE CONFIGURATION ---
st.set_page_config(page_title="OEM Part Identifier", page_icon="üè≠", layout="wide")

# --- SIDEBAR: SETUP ---
with st.sidebar:
    st.header("‚öôÔ∏è Configuration")
    api_key = st.text_input("Enter Gemini API Key", type="password")

    # ADDED: Dropdown for models from your screenshot
    st.markdown("### ü§ñ Select Model")
    st.caption("Switch models if you hit a Rate Limit error.")

    model_choice = st.selectbox(
        "Choose Model:",
        [
            "gemini-2.5-flash",
            "gemini-2.5-flash-lite",
            "gemini-3-flash"
        ],
        index=0,
        help="All these models support Google Search. Switch if one is busy."
    )

    st.divider()
    st.info(f"Active Model: **{model_choice}**")

# --- MAIN APP ---
st.title("üè≠ Industrial OEM Identifier")
st.markdown(f"""
This tool uses **{model_choice}** with **Google Search** to identify manufacturers.
If you see a *429 Resource Exhausted* error, try switching the model in the sidebar.
""")

# --- FILE UPLOADER ---
uploaded_file = st.file_uploader("Upload your Excel or CSV file", type=['xlsx', 'xls', 'csv'])

if uploaded_file is not None:
    try:
        # Load Data
        if uploaded_file.name.endswith('.csv'):
            df = pd.read_csv(uploaded_file)
        else:
            df = pd.read_excel(uploaded_file)

        st.write("### 1. Preview Data")
        st.dataframe(df.head(3), use_container_width=True)

        # Select Column
        all_columns = df.columns.tolist()
        part_col = st.selectbox("Select the column containing PART NUMBERS:", all_columns)

        if st.button("üöÄ Identify OEMs", type="primary"):
            if not api_key:
                st.error("‚ö†Ô∏è Please enter your Gemini API Key in the sidebar first!")
            else:
                # Configure AI
                genai.configure(api_key=api_key)

                # Initialize Selected Model with Search Tool
                model = genai.GenerativeModel(
                    model_name=model_choice,
                    tools='google_search_retrieval'
                )

                progress_bar = st.progress(0)
                status_text = st.empty()

                unique_parts = df[part_col].dropna().unique().tolist()
                total_parts = len(unique_parts)
                results_map = {}

                # BATCH SIZE
                # Your screenshot shows low limits (RPM 5 or 10), so we keep batch size small
                BATCH_SIZE = 5

                for i in range(0, total_parts, BATCH_SIZE):
                    batch = unique_parts[i:i + BATCH_SIZE]

                    status_text.text(f"Processing batch {i//BATCH_SIZE + 1} using {model_choice}...")

                    prompt = f"""
                    Act as an industrial supply chain expert. Identify the Manufacturer (OEM) or Brand for these part numbers: {', '.join(map(str, batch))}.

                    Context: These are likely Industrial Automation, Electrical, or Mechanical spares.

                    Instructions:
                    1. Search the web for each part using the Google Search tool.
                    2. Return ONLY a list of Company Names separated by a pipe symbol (|) in the exact same order as the input.
                    3. If a part belongs to a famous brand (like 'Allen-Bradley'), return the Brand or Parent Company.
                    4. If absolutely unknown after searching, write 'Unknown'.
                    """

                    try:
                        response = model.generate_content(prompt)
                        clean_text = response.text.strip()
                        batch_results = [x.strip() for x in clean_text.split('|')]

                        if len(batch_results) != len(batch):
                            batch_results = ["Error/Mismatch"] * len(batch)

                        for part, result in zip(batch, batch_results):
                            results_map[part] = result

                    except Exception as e:
                        st.error(f"Error on batch: {e}")
                        # If error is rate limit (429), warn user to switch
                        if "429" in str(e):
                            st.warning("‚ö†Ô∏è Rate Limit Reached! Select a different model in the sidebar to continue.")
                        for part in batch:
                            results_map[part] = "Error"

                    progress_bar.progress(min((i + BATCH_SIZE) / total_parts, 1.0))

                    # Polite pause to respect the RPM limits seen in your screenshot
                    time.sleep(2)

                # Finalize
                df['Identified_OEM'] = df[part_col].map(results_map)
                status_text.success(f"‚úÖ Identification Complete using {model_choice}!")

                st.write("### 2. Download Results")
                st.dataframe(df, use_container_width=True)

                csv = df.to_csv(index=False).encode('utf-8')
                st.download_button("üì• Download as CSV", csv, "oem_results.csv", "text/csv")

    except Exception as e:
        st.error(f"Error reading file: {e}")